{"ast":null,"code":"import { Buffer } from 'buffer';\nimport { fetch } from 'cross-fetch';\nclass URLTokenBaseHTTPError extends Error {\n  constructor(message, response) {\n    super(message);\n    this.response = response;\n    this.name = 'URLTokenBaseHTTPError';\n    this.response = response;\n  }\n}\n/**\n * Implementation of BaseHTTPClient that uses a URL and a token\n * and make the REST queries using fetch.\n * This is the default implementation of BaseHTTPClient.\n */\nexport class URLTokenBaseHTTPClient {\n  constructor(tokenHeader, baseServer, port) {\n    let defaultHeaders = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    this.defaultHeaders = defaultHeaders;\n    // Append a trailing slash so we can use relative paths. Without the trailing\n    // slash, the last path segment will be replaced by the relative path. See\n    // usage in `addressWithPath`.\n    const fixedBaseServer = baseServer.endsWith('/') ? baseServer : `${baseServer}/`;\n    const baseServerURL = new URL(fixedBaseServer);\n    if (typeof port !== 'undefined') {\n      baseServerURL.port = port.toString();\n    }\n    if (baseServerURL.protocol.length === 0) {\n      throw new Error('Invalid base server URL, protocol must be defined.');\n    }\n    this.baseURL = baseServerURL;\n    this.tokenHeader = tokenHeader;\n  }\n  /**\n   * Compute the URL for a path relative to the instance's address\n   * @param relativePath - A path string\n   * @param query - An optional key-value object of query parameters to add to the URL. If the\n   *   relativePath already has query parameters on it, the additional parameters defined here will\n   *   be added to the URL without modifying those (unless a key collision occurs).\n   * @returns A URL string\n   */\n  getURL(relativePath, query) {\n    let fixedRelativePath;\n    if (relativePath.startsWith('./')) {\n      fixedRelativePath = relativePath;\n    } else if (relativePath.startsWith('/')) {\n      fixedRelativePath = `.${relativePath}`;\n    } else {\n      fixedRelativePath = `./${relativePath}`;\n    }\n    const address = new URL(fixedRelativePath, this.baseURL);\n    if (query) {\n      for (const [key, value] of Object.entries(query)) {\n        address.searchParams.set(key, value);\n      }\n    }\n    return address.toString();\n  }\n  static formatFetchResponseHeaders(headers) {\n    const headersObj = {};\n    headers.forEach((key, value) => {\n      headersObj[key] = value;\n    });\n    return headersObj;\n  }\n  static async checkHttpError(res) {\n    if (res.ok) {\n      return;\n    }\n    let body = null;\n    let bodyErrorMessage = null;\n    try {\n      body = new Uint8Array(await res.arrayBuffer());\n      const decoded = JSON.parse(Buffer.from(body).toString());\n      if (decoded.message) {\n        bodyErrorMessage = decoded.message;\n      }\n    } catch (_) {\n      // ignore any error that happened while we are parsing the error response\n    }\n    let message = `Network request error. Received status ${res.status} (${res.statusText})`;\n    if (bodyErrorMessage) {\n      message += `: ${bodyErrorMessage}`;\n    }\n    throw new URLTokenBaseHTTPError(message, {\n      body,\n      status: res.status,\n      headers: URLTokenBaseHTTPClient.formatFetchResponseHeaders(res.headers)\n    });\n  }\n  static async formatFetchResponse(res) {\n    await this.checkHttpError(res);\n    return {\n      body: new Uint8Array(await res.arrayBuffer()),\n      status: res.status,\n      headers: URLTokenBaseHTTPClient.formatFetchResponseHeaders(res.headers)\n    };\n  }\n  async get(relativePath, query) {\n    let requestHeaders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // Expand headers for use in fetch\n    const headers = {\n      ...this.tokenHeader,\n      ...this.defaultHeaders,\n      ...requestHeaders\n    };\n    const res = await fetch(this.getURL(relativePath, query), {\n      mode: 'cors',\n      headers\n    });\n    return URLTokenBaseHTTPClient.formatFetchResponse(res);\n  }\n  async post(relativePath, data, query) {\n    let requestHeaders = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    // Expand headers for use in fetch\n    const headers = {\n      ...this.tokenHeader,\n      ...this.defaultHeaders,\n      ...requestHeaders\n    };\n    const res = await fetch(this.getURL(relativePath, query), {\n      method: 'POST',\n      mode: 'cors',\n      body: data,\n      headers\n    });\n    return URLTokenBaseHTTPClient.formatFetchResponse(res);\n  }\n  async delete(relativePath, data, query) {\n    let requestHeaders = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    // Expand headers for use in fetch\n    const headers = {\n      ...this.tokenHeader,\n      ...this.defaultHeaders,\n      ...requestHeaders\n    };\n    const res = await fetch(this.getURL(relativePath, query), {\n      method: 'DELETE',\n      mode: 'cors',\n      body: data,\n      headers\n    });\n    return URLTokenBaseHTTPClient.formatFetchResponse(res);\n  }\n}","map":{"version":3,"names":["Buffer","fetch","URLTokenBaseHTTPError","Error","constructor","message","response","name","URLTokenBaseHTTPClient","tokenHeader","baseServer","port","defaultHeaders","arguments","length","undefined","fixedBaseServer","endsWith","baseServerURL","URL","toString","protocol","baseURL","getURL","relativePath","query","fixedRelativePath","startsWith","address","key","value","Object","entries","searchParams","set","formatFetchResponseHeaders","headers","headersObj","forEach","checkHttpError","res","ok","body","bodyErrorMessage","Uint8Array","arrayBuffer","decoded","JSON","parse","from","_","status","statusText","formatFetchResponse","get","requestHeaders","mode","post","data","method","delete"],"sources":["/home/danica/morra/frontend/node_modules/algosdk/src/client/urlTokenBaseHTTPClient.ts"],"sourcesContent":["import { Buffer } from 'buffer';\nimport { fetch, Response, Headers } from 'cross-fetch';\nimport {\n  BaseHTTPClient,\n  BaseHTTPClientResponse,\n  BaseHTTPClientError,\n  Query,\n} from './baseHTTPClient';\n\nexport interface AlgodTokenHeader {\n  'X-Algo-API-Token': string;\n}\n\nexport interface IndexerTokenHeader {\n  'X-Indexer-API-Token': string;\n}\n\nexport interface KMDTokenHeader {\n  'X-KMD-API-Token': string;\n}\n\nexport interface CustomTokenHeader {\n  [headerName: string]: string;\n}\n\nclass URLTokenBaseHTTPError extends Error implements BaseHTTPClientError {\n  constructor(message: string, public response: BaseHTTPClientResponse) {\n    super(message);\n    this.name = 'URLTokenBaseHTTPError';\n    this.response = response;\n  }\n}\n\nexport type TokenHeader =\n  | AlgodTokenHeader\n  | IndexerTokenHeader\n  | KMDTokenHeader\n  | CustomTokenHeader;\n\n/**\n * Implementation of BaseHTTPClient that uses a URL and a token\n * and make the REST queries using fetch.\n * This is the default implementation of BaseHTTPClient.\n */\nexport class URLTokenBaseHTTPClient implements BaseHTTPClient {\n  private readonly baseURL: URL;\n  private readonly tokenHeader: TokenHeader;\n\n  constructor(\n    tokenHeader: TokenHeader,\n    baseServer: string,\n    port?: string | number,\n    private defaultHeaders: Record<string, any> = {}\n  ) {\n    // Append a trailing slash so we can use relative paths. Without the trailing\n    // slash, the last path segment will be replaced by the relative path. See\n    // usage in `addressWithPath`.\n    const fixedBaseServer = baseServer.endsWith('/')\n      ? baseServer\n      : `${baseServer}/`;\n    const baseServerURL = new URL(fixedBaseServer);\n    if (typeof port !== 'undefined') {\n      baseServerURL.port = port.toString();\n    }\n\n    if (baseServerURL.protocol.length === 0) {\n      throw new Error('Invalid base server URL, protocol must be defined.');\n    }\n\n    this.baseURL = baseServerURL;\n    this.tokenHeader = tokenHeader;\n  }\n\n  /**\n   * Compute the URL for a path relative to the instance's address\n   * @param relativePath - A path string\n   * @param query - An optional key-value object of query parameters to add to the URL. If the\n   *   relativePath already has query parameters on it, the additional parameters defined here will\n   *   be added to the URL without modifying those (unless a key collision occurs).\n   * @returns A URL string\n   */\n  private getURL(relativePath: string, query?: Query<string>): string {\n    let fixedRelativePath: string;\n    if (relativePath.startsWith('./')) {\n      fixedRelativePath = relativePath;\n    } else if (relativePath.startsWith('/')) {\n      fixedRelativePath = `.${relativePath}`;\n    } else {\n      fixedRelativePath = `./${relativePath}`;\n    }\n    const address = new URL(fixedRelativePath, this.baseURL);\n    if (query) {\n      for (const [key, value] of Object.entries(query)) {\n        address.searchParams.set(key, value);\n      }\n    }\n    return address.toString();\n  }\n\n  private static formatFetchResponseHeaders(\n    headers: Headers\n  ): Record<string, string> {\n    const headersObj: Record<string, string> = {};\n    headers.forEach((key, value) => {\n      headersObj[key] = value;\n    });\n    return headersObj;\n  }\n\n  private static async checkHttpError(res: Response) {\n    if (res.ok) {\n      return;\n    }\n\n    let body: Uint8Array | null = null;\n    let bodyErrorMessage: string | null = null;\n\n    try {\n      body = new Uint8Array(await res.arrayBuffer());\n      const decoded: Record<string, any> = JSON.parse(\n        Buffer.from(body).toString()\n      );\n      if (decoded.message) {\n        bodyErrorMessage = decoded.message;\n      }\n    } catch (_) {\n      // ignore any error that happened while we are parsing the error response\n    }\n\n    let message = `Network request error. Received status ${res.status} (${res.statusText})`;\n    if (bodyErrorMessage) {\n      message += `: ${bodyErrorMessage}`;\n    }\n\n    throw new URLTokenBaseHTTPError(message, {\n      body,\n      status: res.status,\n      headers: URLTokenBaseHTTPClient.formatFetchResponseHeaders(res.headers),\n    });\n  }\n\n  private static async formatFetchResponse(\n    res: Response\n  ): Promise<BaseHTTPClientResponse> {\n    await this.checkHttpError(res);\n    return {\n      body: new Uint8Array(await res.arrayBuffer()),\n      status: res.status,\n      headers: URLTokenBaseHTTPClient.formatFetchResponseHeaders(res.headers),\n    };\n  }\n\n  async get(\n    relativePath: string,\n    query?: Query<string>,\n    requestHeaders: Record<string, string> = {}\n  ): Promise<BaseHTTPClientResponse> {\n    // Expand headers for use in fetch\n    const headers = {\n      ...this.tokenHeader,\n      ...this.defaultHeaders,\n      ...requestHeaders,\n    };\n\n    const res = await fetch(this.getURL(relativePath, query), {\n      mode: 'cors',\n      headers,\n    });\n\n    return URLTokenBaseHTTPClient.formatFetchResponse(res);\n  }\n\n  async post(\n    relativePath: string,\n    data: Uint8Array,\n    query?: Query<string>,\n    requestHeaders: Record<string, string> = {}\n  ): Promise<BaseHTTPClientResponse> {\n    // Expand headers for use in fetch\n    const headers = {\n      ...this.tokenHeader,\n      ...this.defaultHeaders,\n      ...requestHeaders,\n    };\n\n    const res = await fetch(this.getURL(relativePath, query), {\n      method: 'POST',\n      mode: 'cors',\n      body: data,\n      headers,\n    });\n\n    return URLTokenBaseHTTPClient.formatFetchResponse(res);\n  }\n\n  async delete(\n    relativePath: string,\n    data: Uint8Array,\n    query?: Query<string>,\n    requestHeaders: Record<string, string> = {}\n  ): Promise<BaseHTTPClientResponse> {\n    // Expand headers for use in fetch\n    const headers = {\n      ...this.tokenHeader,\n      ...this.defaultHeaders,\n      ...requestHeaders,\n    };\n\n    const res = await fetch(this.getURL(relativePath, query), {\n      method: 'DELETE',\n      mode: 'cors',\n      body: data,\n      headers,\n    });\n\n    return URLTokenBaseHTTPClient.formatFetchResponse(res);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}