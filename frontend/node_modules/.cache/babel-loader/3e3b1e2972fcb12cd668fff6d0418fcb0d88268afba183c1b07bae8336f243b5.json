{"ast":null,"code":"import { Buffer } from 'buffer';\nimport { ABIAddressType, abiCheckTransactionType, ABIReferenceType, ABITupleType, abiTypeIsReference, abiTypeIsTransaction, ABIUintType } from './abi';\nimport { assignGroupID } from './group';\nimport { makeApplicationCallTxnFromObject } from './makeTxn';\nimport { isTransactionWithSigner } from './signer';\nimport { decodeSignedTransaction, Transaction } from './transaction';\nimport { OnApplicationComplete } from './types/transactions/base';\nimport { waitForConfirmation } from './wait';\n// First 4 bytes of SHA-512/256 hash of \"return\"\nconst RETURN_PREFIX = Buffer.from([21, 31, 124, 117]);\n// The maximum number of arguments for an application call transaction\nconst MAX_APP_ARGS = 16;\nexport var AtomicTransactionComposerStatus;\n(function (AtomicTransactionComposerStatus) {\n  /** The atomic group is still under construction. */\n  AtomicTransactionComposerStatus[AtomicTransactionComposerStatus[\"BUILDING\"] = 0] = \"BUILDING\";\n  /** The atomic group has been finalized, but not yet signed. */\n  AtomicTransactionComposerStatus[AtomicTransactionComposerStatus[\"BUILT\"] = 1] = \"BUILT\";\n  /** The atomic group has been finalized and signed, but not yet submitted to the network. */\n  AtomicTransactionComposerStatus[AtomicTransactionComposerStatus[\"SIGNED\"] = 2] = \"SIGNED\";\n  /** The atomic group has been finalized, signed, and submitted to the network. */\n  AtomicTransactionComposerStatus[AtomicTransactionComposerStatus[\"SUBMITTED\"] = 3] = \"SUBMITTED\";\n  /** The atomic group has been finalized, signed, submitted, and successfully committed to a block. */\n  AtomicTransactionComposerStatus[AtomicTransactionComposerStatus[\"COMMITTED\"] = 4] = \"COMMITTED\";\n})(AtomicTransactionComposerStatus || (AtomicTransactionComposerStatus = {}));\n/**\n * Add a value to an application call's foreign array. The addition will be as compact as possible,\n * and this function will return an index that can be used to reference `valueToAdd` in `array`.\n *\n * @param valueToAdd - The value to add to the array. If this value is already present in the array,\n *   it will not be added again. Instead, the existing index will be returned.\n * @param array - The existing foreign array. This input may be modified to append `valueToAdd`.\n * @param zeroValue - If provided, this value indicated two things: the 0 value is special for this\n *   array, so all indexes into `array` must start at 1; additionally, if `valueToAdd` equals\n *   `zeroValue`, then `valueToAdd` will not be added to the array, and instead the 0 indexes will\n *   be returned.\n * @returns An index that can be used to reference `valueToAdd` in `array`.\n */\nfunction populateForeignArray(valueToAdd, array, zeroValue) {\n  if (zeroValue != null && valueToAdd === zeroValue) {\n    return 0;\n  }\n  const offset = zeroValue == null ? 0 : 1;\n  for (let i = 0; i < array.length; i++) {\n    if (valueToAdd === array[i]) {\n      return i + offset;\n    }\n  }\n  array.push(valueToAdd);\n  return array.length - 1 + offset;\n}\n/** A class used to construct and execute atomic transaction groups */\nexport class AtomicTransactionComposer {\n  constructor() {\n    this.status = AtomicTransactionComposerStatus.BUILDING;\n    this.transactions = [];\n    this.methodCalls = new Map();\n    this.signedTxns = [];\n    this.txIDs = [];\n  }\n  /**\n   * Get the status of this composer's transaction group.\n   */\n  getStatus() {\n    return this.status;\n  }\n  /**\n   * Get the number of transactions currently in this atomic group.\n   */\n  count() {\n    return this.transactions.length;\n  }\n  /**\n   * Create a new composer with the same underlying transactions. The new composer's status will be\n   * BUILDING, so additional transactions may be added to it.\n   */\n  clone() {\n    const theClone = new AtomicTransactionComposer();\n    theClone.transactions = this.transactions.map(_ref => {\n      let {\n        txn,\n        signer\n      } = _ref;\n      return {\n        // not quite a deep copy, but good enough for our purposes (modifying txn.group in buildGroup)\n        txn: Transaction.from_obj_for_encoding({\n          ...txn.get_obj_for_encoding(),\n          // erase the group ID\n          grp: undefined\n        }),\n        signer\n      };\n    });\n    theClone.methodCalls = new Map(this.methodCalls);\n    return theClone;\n  }\n  /**\n   * Add a transaction to this atomic group.\n   *\n   * An error will be thrown if the transaction has a nonzero group ID, the composer's status is\n   * not BUILDING, or if adding this transaction causes the current group to exceed MAX_GROUP_SIZE.\n   */\n  addTransaction(txnAndSigner) {\n    if (this.status !== AtomicTransactionComposerStatus.BUILDING) {\n      throw new Error('Cannot add transactions when composer status is not BUILDING');\n    }\n    if (this.transactions.length === AtomicTransactionComposer.MAX_GROUP_SIZE) {\n      throw new Error(`Adding an additional transaction exceeds the maximum atomic group size of ${AtomicTransactionComposer.MAX_GROUP_SIZE}`);\n    }\n    if (txnAndSigner.txn.group && txnAndSigner.txn.group.some(v => v !== 0)) {\n      throw new Error('Cannot add a transaction with nonzero group ID');\n    }\n    this.transactions.push(txnAndSigner);\n  }\n  /**\n   * Add a smart contract method call to this atomic group.\n   *\n   * An error will be thrown if the composer's status is not BUILDING, if adding this transaction\n   * causes the current group to exceed MAX_GROUP_SIZE, or if the provided arguments are invalid\n   * for the given method.\n   */\n  addMethodCall(_ref2) {\n    let {\n      appID,\n      method,\n      methodArgs,\n      sender,\n      suggestedParams,\n      onComplete,\n      approvalProgram,\n      clearProgram,\n      numGlobalInts,\n      numGlobalByteSlices,\n      numLocalInts,\n      numLocalByteSlices,\n      extraPages,\n      appAccounts,\n      appForeignApps,\n      appForeignAssets,\n      boxes,\n      note,\n      lease,\n      rekeyTo,\n      signer\n    } = _ref2;\n    if (this.status !== AtomicTransactionComposerStatus.BUILDING) {\n      throw new Error('Cannot add transactions when composer status is not BUILDING');\n    }\n    if (this.transactions.length + method.txnCount() > AtomicTransactionComposer.MAX_GROUP_SIZE) {\n      throw new Error(`Adding additional transactions exceeds the maximum atomic group size of ${AtomicTransactionComposer.MAX_GROUP_SIZE}`);\n    }\n    if (appID === 0) {\n      if (approvalProgram == null || clearProgram == null || numGlobalInts == null || numGlobalByteSlices == null || numLocalInts == null || numLocalByteSlices == null) {\n        throw new Error('One of the following required parameters for application creation is missing: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices');\n      }\n    } else if (onComplete === OnApplicationComplete.UpdateApplicationOC) {\n      if (approvalProgram == null || clearProgram == null) {\n        throw new Error('One of the following required parameters for OnApplicationComplete.UpdateApplicationOC is missing: approvalProgram, clearProgram');\n      }\n      if (numGlobalInts != null || numGlobalByteSlices != null || numLocalInts != null || numLocalByteSlices != null || extraPages != null) {\n        throw new Error('One of the following application creation parameters were set on a non-creation call: numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages');\n      }\n    } else if (approvalProgram != null || clearProgram != null || numGlobalInts != null || numGlobalByteSlices != null || numLocalInts != null || numLocalByteSlices != null || extraPages != null) {\n      throw new Error('One of the following application creation parameters were set on a non-creation call: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages');\n    }\n    if (methodArgs == null) {\n      // eslint-disable-next-line no-param-reassign\n      methodArgs = [];\n    }\n    if (methodArgs.length !== method.args.length) {\n      throw new Error(`Incorrect number of method arguments. Expected ${method.args.length}, got ${methodArgs.length}`);\n    }\n    let basicArgTypes = [];\n    let basicArgValues = [];\n    const txnArgs = [];\n    const refArgTypes = [];\n    const refArgValues = [];\n    const refArgIndexToBasicArgIndex = new Map();\n    // TODO: Box encoding for ABI\n    const boxReferences = !boxes ? [] : boxes;\n    for (let i = 0; i < methodArgs.length; i++) {\n      let argType = method.args[i].type;\n      const argValue = methodArgs[i];\n      if (abiTypeIsTransaction(argType)) {\n        if (!isTransactionWithSigner(argValue) || !abiCheckTransactionType(argType, argValue.txn)) {\n          throw new Error(`Expected ${argType} transaction for argument at index ${i}`);\n        }\n        if (argValue.txn.group && argValue.txn.group.some(v => v !== 0)) {\n          throw new Error('Cannot add a transaction with nonzero group ID');\n        }\n        txnArgs.push(argValue);\n        continue;\n      }\n      if (isTransactionWithSigner(argValue)) {\n        throw new Error(`Expected non-transaction value for argument at index ${i}`);\n      }\n      if (abiTypeIsReference(argType)) {\n        refArgIndexToBasicArgIndex.set(refArgTypes.length, basicArgTypes.length);\n        refArgTypes.push(argType);\n        refArgValues.push(argValue);\n        // treat the reference as a uint8 for encoding purposes\n        argType = new ABIUintType(8);\n      }\n      if (typeof argType === 'string') {\n        throw new Error(`Unknown ABI type: ${argType}`);\n      }\n      basicArgTypes.push(argType);\n      basicArgValues.push(argValue);\n    }\n    const resolvedRefIndexes = [];\n    const foreignAccounts = appAccounts == null ? [] : appAccounts.slice();\n    const foreignApps = appForeignApps == null ? [] : appForeignApps.slice();\n    const foreignAssets = appForeignAssets == null ? [] : appForeignAssets.slice();\n    for (let i = 0; i < refArgTypes.length; i++) {\n      const refType = refArgTypes[i];\n      const refValue = refArgValues[i];\n      let resolved = 0;\n      switch (refType) {\n        case ABIReferenceType.account:\n          {\n            const addressType = new ABIAddressType();\n            const address = addressType.decode(addressType.encode(refValue));\n            resolved = populateForeignArray(address, foreignAccounts, sender);\n            break;\n          }\n        case ABIReferenceType.application:\n          {\n            const uint64Type = new ABIUintType(64);\n            const refAppID = uint64Type.decode(uint64Type.encode(refValue));\n            if (refAppID > Number.MAX_SAFE_INTEGER) {\n              throw new Error(`Expected safe integer for application value, got ${refAppID}`);\n            }\n            resolved = populateForeignArray(Number(refAppID), foreignApps, appID);\n            break;\n          }\n        case ABIReferenceType.asset:\n          {\n            const uint64Type = new ABIUintType(64);\n            const refAssetID = uint64Type.decode(uint64Type.encode(refValue));\n            if (refAssetID > Number.MAX_SAFE_INTEGER) {\n              throw new Error(`Expected safe integer for asset value, got ${refAssetID}`);\n            }\n            resolved = populateForeignArray(Number(refAssetID), foreignAssets);\n            break;\n          }\n        default:\n          throw new Error(`Unknown reference type: ${refType}`);\n      }\n      resolvedRefIndexes.push(resolved);\n    }\n    for (let i = 0; i < resolvedRefIndexes.length; i++) {\n      const basicArgIndex = refArgIndexToBasicArgIndex.get(i);\n      basicArgValues[basicArgIndex] = resolvedRefIndexes[i];\n    }\n    if (basicArgTypes.length > MAX_APP_ARGS - 1) {\n      const lastArgTupleTypes = basicArgTypes.slice(MAX_APP_ARGS - 2);\n      const lastArgTupleValues = basicArgValues.slice(MAX_APP_ARGS - 2);\n      basicArgTypes = basicArgTypes.slice(0, MAX_APP_ARGS - 2);\n      basicArgValues = basicArgValues.slice(0, MAX_APP_ARGS - 2);\n      basicArgTypes.push(new ABITupleType(lastArgTupleTypes));\n      basicArgValues.push(lastArgTupleValues);\n    }\n    const appArgsEncoded = [method.getSelector()];\n    for (let i = 0; i < basicArgTypes.length; i++) {\n      appArgsEncoded.push(basicArgTypes[i].encode(basicArgValues[i]));\n    }\n    const appCall = {\n      txn: makeApplicationCallTxnFromObject({\n        from: sender,\n        appIndex: appID,\n        appArgs: appArgsEncoded,\n        accounts: foreignAccounts,\n        foreignApps,\n        foreignAssets,\n        boxes: boxReferences,\n        onComplete: onComplete == null ? OnApplicationComplete.NoOpOC : onComplete,\n        approvalProgram,\n        clearProgram,\n        numGlobalInts,\n        numGlobalByteSlices,\n        numLocalInts,\n        numLocalByteSlices,\n        extraPages,\n        lease,\n        note,\n        rekeyTo,\n        suggestedParams\n      }),\n      signer\n    };\n    this.transactions.push(...txnArgs, appCall);\n    this.methodCalls.set(this.transactions.length - 1, method);\n  }\n  /**\n   * Finalize the transaction group and returned the finalized transactions.\n   *\n   * The composer's status will be at least BUILT after executing this method.\n   */\n  buildGroup() {\n    if (this.status === AtomicTransactionComposerStatus.BUILDING) {\n      if (this.transactions.length === 0) {\n        throw new Error('Cannot build a group with 0 transactions');\n      }\n      if (this.transactions.length > 1) {\n        assignGroupID(this.transactions.map(txnWithSigner => txnWithSigner.txn));\n      }\n      this.status = AtomicTransactionComposerStatus.BUILT;\n    }\n    return this.transactions;\n  }\n  /**\n   * Obtain signatures for each transaction in this group. If signatures have already been obtained,\n   * this method will return cached versions of the signatures.\n   *\n   * The composer's status will be at least SIGNED after executing this method.\n   *\n   * An error will be thrown if signing any of the transactions fails.\n   *\n   * @returns A promise that resolves to an array of signed transactions.\n   */\n  async gatherSignatures() {\n    if (this.status >= AtomicTransactionComposerStatus.SIGNED) {\n      return this.signedTxns;\n    }\n    // retrieve built transactions and verify status is BUILT\n    const txnsWithSigners = this.buildGroup();\n    const txnGroup = txnsWithSigners.map(txnWithSigner => txnWithSigner.txn);\n    const indexesPerSigner = new Map();\n    for (let i = 0; i < txnsWithSigners.length; i++) {\n      const {\n        signer\n      } = txnsWithSigners[i];\n      if (!indexesPerSigner.has(signer)) {\n        indexesPerSigner.set(signer, []);\n      }\n      indexesPerSigner.get(signer).push(i);\n    }\n    const orderedSigners = Array.from(indexesPerSigner);\n    const batchedSigs = await Promise.all(orderedSigners.map(_ref3 => {\n      let [signer, indexes] = _ref3;\n      return signer(txnGroup, indexes);\n    }));\n    const signedTxns = txnsWithSigners.map(() => null);\n    for (let signerIndex = 0; signerIndex < orderedSigners.length; signerIndex++) {\n      const indexes = orderedSigners[signerIndex][1];\n      const sigs = batchedSigs[signerIndex];\n      for (let i = 0; i < indexes.length; i++) {\n        signedTxns[indexes[i]] = sigs[i];\n      }\n    }\n    if (!signedTxns.every(sig => sig != null)) {\n      throw new Error(`Missing signatures. Got ${signedTxns}`);\n    }\n    const txIDs = signedTxns.map((stxn, index) => {\n      try {\n        return decodeSignedTransaction(stxn).txn.txID();\n      } catch (err) {\n        throw new Error(`Cannot decode signed transaction at index ${index}. ${err}`);\n      }\n    });\n    this.signedTxns = signedTxns;\n    this.txIDs = txIDs;\n    this.status = AtomicTransactionComposerStatus.SIGNED;\n    return signedTxns;\n  }\n  /**\n   * Send the transaction group to the network, but don't wait for it to be committed to a block. An\n   * error will be thrown if submission fails.\n   *\n   * The composer's status must be SUBMITTED or lower before calling this method. If submission is\n   * successful, this composer's status will update to SUBMITTED.\n   *\n   * Note: a group can only be submitted again if it fails.\n   *\n   * @param client - An Algodv2 client\n   *\n   * @returns A promise that, upon success, resolves to a list of TxIDs of the submitted transactions.\n   */\n  async submit(client) {\n    if (this.status > AtomicTransactionComposerStatus.SUBMITTED) {\n      throw new Error('Transaction group cannot be resubmitted');\n    }\n    const stxns = await this.gatherSignatures();\n    await client.sendRawTransaction(stxns).do();\n    this.status = AtomicTransactionComposerStatus.SUBMITTED;\n    return this.txIDs;\n  }\n  /**\n   * Simulates the transaction group in the network.\n   *\n   * The composer will try to sign any transactions in the group, then simulate\n   * the results.\n   * Simulating the group will not change the composer's status.\n   *\n   * @param client - An Algodv2 client\n   *\n   * @returns A promise that, upon success, resolves to an object containing an\n   *   array of results containing one element for each method call transaction\n   *   in this group (ABIResult[]) and the SimulateResponse object.\n   */\n  async simulate(client) {\n    if (this.status > AtomicTransactionComposerStatus.SUBMITTED) {\n      throw new Error('Simulated Transaction group has already been submitted to the network');\n    }\n    const stxns = await this.gatherSignatures();\n    const simulateResponse = await client.simulateRawTransactions(stxns).do();\n    // Parse method response\n    const methodResults = [];\n    for (const [txnIndex, method] of this.methodCalls) {\n      const txID = this.txIDs[txnIndex];\n      const pendingInfo = simulateResponse.txnGroups[0].txnResults[txnIndex].txnResult;\n      const methodResult = {\n        txID,\n        rawReturnValue: new Uint8Array(),\n        method\n      };\n      methodResults.push(AtomicTransactionComposer.parseMethodResponse(method, methodResult, pendingInfo.get_obj_for_encoding()));\n    }\n    return {\n      methodResults,\n      simulateResponse\n    };\n  }\n  /**\n   * Send the transaction group to the network and wait until it's committed to a block. An error\n   * will be thrown if submission or execution fails.\n   *\n   * The composer's status must be SUBMITTED or lower before calling this method, since execution is\n   * only allowed once. If submission is successful, this composer's status will update to SUBMITTED.\n   * If the execution is also successful, this composer's status will update to COMMITTED.\n   *\n   * Note: a group can only be submitted again if it fails.\n   *\n   * @param client - An Algodv2 client\n   * @param waitRounds - The maximum number of rounds to wait for transaction confirmation\n   *\n   * @returns A promise that, upon success, resolves to an object containing the confirmed round for\n   *   this transaction, the txIDs of the submitted transactions, and an array of results containing\n   *   one element for each method call transaction in this group.\n   */\n  async execute(client, waitRounds) {\n    if (this.status === AtomicTransactionComposerStatus.COMMITTED) {\n      throw new Error('Transaction group has already been executed successfully');\n    }\n    const txIDs = await this.submit(client);\n    this.status = AtomicTransactionComposerStatus.SUBMITTED;\n    const firstMethodCallIndex = this.transactions.findIndex((_, index) => this.methodCalls.has(index));\n    const indexToWaitFor = firstMethodCallIndex === -1 ? 0 : firstMethodCallIndex;\n    const confirmedTxnInfo = await waitForConfirmation(client, txIDs[indexToWaitFor], waitRounds);\n    this.status = AtomicTransactionComposerStatus.COMMITTED;\n    const confirmedRound = confirmedTxnInfo['confirmed-round'];\n    const methodResults = [];\n    for (const [txnIndex, method] of this.methodCalls) {\n      const txID = txIDs[txnIndex];\n      let methodResult = {\n        txID,\n        rawReturnValue: new Uint8Array(),\n        method\n      };\n      try {\n        const pendingInfo = txnIndex === firstMethodCallIndex ? confirmedTxnInfo :\n        // eslint-disable-next-line no-await-in-loop\n        await client.pendingTransactionInformation(txID).do();\n        methodResult = AtomicTransactionComposer.parseMethodResponse(method, methodResult, pendingInfo);\n      } catch (err) {\n        methodResult.decodeError = err;\n      }\n      methodResults.push(methodResult);\n    }\n    return {\n      confirmedRound,\n      txIDs,\n      methodResults\n    };\n  }\n  /**\n   * Parses a single ABI Method transaction log into a ABI result object.\n   *\n   * @param method\n   * @param methodResult\n   * @param pendingInfo\n   * @returns An ABIResult object\n   */\n  static parseMethodResponse(method, methodResult, pendingInfo) {\n    const returnedResult = methodResult;\n    try {\n      returnedResult.txInfo = pendingInfo;\n      if (method.returns.type !== 'void') {\n        const logs = pendingInfo.logs || [];\n        if (logs.length === 0) {\n          throw new Error('App call transaction did not log a return value');\n        }\n        const lastLog = Buffer.from(logs[logs.length - 1], 'base64');\n        if (lastLog.byteLength < 4 || !lastLog.slice(0, 4).equals(RETURN_PREFIX)) {\n          throw new Error('App call transaction did not log a return value');\n        }\n        returnedResult.rawReturnValue = new Uint8Array(lastLog.slice(4));\n        returnedResult.returnValue = method.returns.type.decode(methodResult.rawReturnValue);\n      }\n    } catch (err) {\n      returnedResult.decodeError = err;\n    }\n    return returnedResult;\n  }\n}\n/** The maximum size of an atomic transaction group. */\nAtomicTransactionComposer.MAX_GROUP_SIZE = 16;","map":{"version":3,"names":["Buffer","ABIAddressType","abiCheckTransactionType","ABIReferenceType","ABITupleType","abiTypeIsReference","abiTypeIsTransaction","ABIUintType","assignGroupID","makeApplicationCallTxnFromObject","isTransactionWithSigner","decodeSignedTransaction","Transaction","OnApplicationComplete","waitForConfirmation","RETURN_PREFIX","from","MAX_APP_ARGS","AtomicTransactionComposerStatus","populateForeignArray","valueToAdd","array","zeroValue","offset","i","length","push","AtomicTransactionComposer","constructor","status","BUILDING","transactions","methodCalls","Map","signedTxns","txIDs","getStatus","count","clone","theClone","map","_ref","txn","signer","from_obj_for_encoding","get_obj_for_encoding","grp","undefined","addTransaction","txnAndSigner","Error","MAX_GROUP_SIZE","group","some","v","addMethodCall","_ref2","appID","method","methodArgs","sender","suggestedParams","onComplete","approvalProgram","clearProgram","numGlobalInts","numGlobalByteSlices","numLocalInts","numLocalByteSlices","extraPages","appAccounts","appForeignApps","appForeignAssets","boxes","note","lease","rekeyTo","txnCount","UpdateApplicationOC","args","basicArgTypes","basicArgValues","txnArgs","refArgTypes","refArgValues","refArgIndexToBasicArgIndex","boxReferences","argType","type","argValue","set","resolvedRefIndexes","foreignAccounts","slice","foreignApps","foreignAssets","refType","refValue","resolved","account","addressType","address","decode","encode","application","uint64Type","refAppID","Number","MAX_SAFE_INTEGER","asset","refAssetID","basicArgIndex","get","lastArgTupleTypes","lastArgTupleValues","appArgsEncoded","getSelector","appCall","appIndex","appArgs","accounts","NoOpOC","buildGroup","txnWithSigner","BUILT","gatherSignatures","SIGNED","txnsWithSigners","txnGroup","indexesPerSigner","has","orderedSigners","Array","batchedSigs","Promise","all","_ref3","indexes","signerIndex","sigs","every","sig","stxn","index","txID","err","submit","client","SUBMITTED","stxns","sendRawTransaction","do","simulate","simulateResponse","simulateRawTransactions","methodResults","txnIndex","pendingInfo","txnGroups","txnResults","txnResult","methodResult","rawReturnValue","Uint8Array","parseMethodResponse","execute","waitRounds","COMMITTED","firstMethodCallIndex","findIndex","_","indexToWaitFor","confirmedTxnInfo","confirmedRound","pendingTransactionInformation","decodeError","returnedResult","txInfo","returns","logs","lastLog","byteLength","equals","returnValue"],"sources":["/home/danica/morra/frontend/node_modules/algosdk/src/composer.ts"],"sourcesContent":["import { Buffer } from 'buffer';\nimport {\n  ABIAddressType,\n  abiCheckTransactionType,\n  ABIMethod,\n  ABIReferenceType,\n  ABITupleType,\n  ABIType,\n  abiTypeIsReference,\n  abiTypeIsTransaction,\n  ABIUintType,\n  ABIValue,\n} from './abi';\nimport Algodv2 from './client/v2/algod/algod';\nimport { SimulateResponse } from './client/v2/algod/models/types';\nimport { assignGroupID } from './group';\nimport { makeApplicationCallTxnFromObject } from './makeTxn';\nimport {\n  isTransactionWithSigner,\n  TransactionSigner,\n  TransactionWithSigner,\n} from './signer';\nimport { decodeSignedTransaction, Transaction } from './transaction';\nimport {\n  BoxReference,\n  OnApplicationComplete,\n  SuggestedParams,\n} from './types/transactions/base';\nimport { waitForConfirmation } from './wait';\n\n// First 4 bytes of SHA-512/256 hash of \"return\"\nconst RETURN_PREFIX = Buffer.from([21, 31, 124, 117]);\n\n// The maximum number of arguments for an application call transaction\nconst MAX_APP_ARGS = 16;\n\nexport type ABIArgument = ABIValue | TransactionWithSigner;\n\n/** Represents the output from a successful ABI method call. */\nexport interface ABIResult {\n  /** The TxID of the transaction that invoked the ABI method call. */\n  txID: string;\n  /**\n   * The raw bytes of the return value from the ABI method call. This will be empty if the method\n   * does not return a value (return type \"void\").\n   */\n  rawReturnValue: Uint8Array;\n  /**\n   * The method that was called for this result\n   */\n  method: ABIMethod;\n  /**\n   * The return value from the ABI method call. This will be undefined if the method does not return\n   * a value (return type \"void\"), or if the SDK was unable to decode the returned value.\n   */\n  returnValue?: ABIValue;\n  /** If the SDK was unable to decode a return value, the error will be here. */\n  decodeError?: Error;\n  /** The pending transaction information from the method transaction */\n  txInfo?: Record<string, any>;\n}\n\nexport enum AtomicTransactionComposerStatus {\n  /** The atomic group is still under construction. */\n  BUILDING,\n\n  /** The atomic group has been finalized, but not yet signed. */\n  BUILT,\n\n  /** The atomic group has been finalized and signed, but not yet submitted to the network. */\n  SIGNED,\n\n  /** The atomic group has been finalized, signed, and submitted to the network. */\n  SUBMITTED,\n\n  /** The atomic group has been finalized, signed, submitted, and successfully committed to a block. */\n  COMMITTED,\n}\n\n/**\n * Add a value to an application call's foreign array. The addition will be as compact as possible,\n * and this function will return an index that can be used to reference `valueToAdd` in `array`.\n *\n * @param valueToAdd - The value to add to the array. If this value is already present in the array,\n *   it will not be added again. Instead, the existing index will be returned.\n * @param array - The existing foreign array. This input may be modified to append `valueToAdd`.\n * @param zeroValue - If provided, this value indicated two things: the 0 value is special for this\n *   array, so all indexes into `array` must start at 1; additionally, if `valueToAdd` equals\n *   `zeroValue`, then `valueToAdd` will not be added to the array, and instead the 0 indexes will\n *   be returned.\n * @returns An index that can be used to reference `valueToAdd` in `array`.\n */\nfunction populateForeignArray<Type>(\n  valueToAdd: Type,\n  array: Type[],\n  zeroValue?: Type\n): number {\n  if (zeroValue != null && valueToAdd === zeroValue) {\n    return 0;\n  }\n\n  const offset = zeroValue == null ? 0 : 1;\n\n  for (let i = 0; i < array.length; i++) {\n    if (valueToAdd === array[i]) {\n      return i + offset;\n    }\n  }\n\n  array.push(valueToAdd);\n  return array.length - 1 + offset;\n}\n\n/** A class used to construct and execute atomic transaction groups */\nexport class AtomicTransactionComposer {\n  /** The maximum size of an atomic transaction group. */\n  static MAX_GROUP_SIZE: number = 16;\n\n  private status = AtomicTransactionComposerStatus.BUILDING;\n  private transactions: TransactionWithSigner[] = [];\n  private methodCalls: Map<number, ABIMethod> = new Map();\n  private signedTxns: Uint8Array[] = [];\n  private txIDs: string[] = [];\n\n  /**\n   * Get the status of this composer's transaction group.\n   */\n  getStatus(): AtomicTransactionComposerStatus {\n    return this.status;\n  }\n\n  /**\n   * Get the number of transactions currently in this atomic group.\n   */\n  count(): number {\n    return this.transactions.length;\n  }\n\n  /**\n   * Create a new composer with the same underlying transactions. The new composer's status will be\n   * BUILDING, so additional transactions may be added to it.\n   */\n  clone(): AtomicTransactionComposer {\n    const theClone = new AtomicTransactionComposer();\n\n    theClone.transactions = this.transactions.map(({ txn, signer }) => ({\n      // not quite a deep copy, but good enough for our purposes (modifying txn.group in buildGroup)\n      txn: Transaction.from_obj_for_encoding({\n        ...txn.get_obj_for_encoding(),\n        // erase the group ID\n        grp: undefined,\n      }),\n      signer,\n    }));\n    theClone.methodCalls = new Map(this.methodCalls);\n\n    return theClone;\n  }\n\n  /**\n   * Add a transaction to this atomic group.\n   *\n   * An error will be thrown if the transaction has a nonzero group ID, the composer's status is\n   * not BUILDING, or if adding this transaction causes the current group to exceed MAX_GROUP_SIZE.\n   */\n  addTransaction(txnAndSigner: TransactionWithSigner): void {\n    if (this.status !== AtomicTransactionComposerStatus.BUILDING) {\n      throw new Error(\n        'Cannot add transactions when composer status is not BUILDING'\n      );\n    }\n\n    if (this.transactions.length === AtomicTransactionComposer.MAX_GROUP_SIZE) {\n      throw new Error(\n        `Adding an additional transaction exceeds the maximum atomic group size of ${AtomicTransactionComposer.MAX_GROUP_SIZE}`\n      );\n    }\n\n    if (txnAndSigner.txn.group && txnAndSigner.txn.group.some((v) => v !== 0)) {\n      throw new Error('Cannot add a transaction with nonzero group ID');\n    }\n\n    this.transactions.push(txnAndSigner);\n  }\n\n  /**\n   * Add a smart contract method call to this atomic group.\n   *\n   * An error will be thrown if the composer's status is not BUILDING, if adding this transaction\n   * causes the current group to exceed MAX_GROUP_SIZE, or if the provided arguments are invalid\n   * for the given method.\n   */\n  addMethodCall({\n    appID,\n    method,\n    methodArgs,\n    sender,\n    suggestedParams,\n    onComplete,\n    approvalProgram,\n    clearProgram,\n    numGlobalInts,\n    numGlobalByteSlices,\n    numLocalInts,\n    numLocalByteSlices,\n    extraPages,\n    appAccounts,\n    appForeignApps,\n    appForeignAssets,\n    boxes,\n    note,\n    lease,\n    rekeyTo,\n    signer,\n  }: {\n    /** The ID of the smart contract to call. Set this to 0 to indicate an application creation call. */\n    appID: number;\n    /** The method to call on the smart contract */\n    method: ABIMethod;\n    /** The arguments to include in the method call. If omitted, no arguments will be passed to the method. */\n    methodArgs?: ABIArgument[];\n    /** The address of the sender of this application call */\n    sender: string;\n    /** Transactions params to use for this application call */\n    suggestedParams: SuggestedParams;\n    /** The OnComplete action to take for this application call. If omitted, OnApplicationComplete.NoOpOC will be used. */\n    onComplete?: OnApplicationComplete;\n    /** The approval program for this application call. Only set this if this is an application creation call, or if onComplete is OnApplicationComplete.UpdateApplicationOC */\n    approvalProgram?: Uint8Array;\n    /** The clear program for this application call. Only set this if this is an application creation call, or if onComplete is OnApplicationComplete.UpdateApplicationOC */\n    clearProgram?: Uint8Array;\n    /** The global integer schema size. Only set this if this is an application creation call. */\n    numGlobalInts?: number;\n    /** The global byte slice schema size. Only set this if this is an application creation call. */\n    numGlobalByteSlices?: number;\n    /** The local integer schema size. Only set this if this is an application creation call. */\n    numLocalInts?: number;\n    /** The local byte slice schema size. Only set this if this is an application creation call. */\n    numLocalByteSlices?: number;\n    /** The number of extra pages to allocate for the application's programs. Only set this if this is an application creation call. If omitted, defaults to 0. */\n    extraPages?: number;\n    /** Array of Address strings that represent external accounts supplied to this application. If accounts are provided here, the accounts specified in the method args will appear after these. */\n    appAccounts?: string[];\n    /** Array of App ID numbers that represent external apps supplied to this application. If apps are provided here, the apps specified in the method args will appear after these. */\n    appForeignApps?: number[];\n    /** Array of Asset ID numbers that represent external assets supplied to this application. If assets are provided here, the assets specified in the method args will appear after these. */\n    appForeignAssets?: number[];\n    /** The box references for this application call */\n    boxes?: BoxReference[];\n    /** The note value for this application call */\n    note?: Uint8Array;\n    /** The lease value for this application call */\n    lease?: Uint8Array;\n    /** If provided, the address that the sender will be rekeyed to at the conclusion of this application call */\n    rekeyTo?: string;\n    /** A transaction signer that can authorize this application call from sender */\n    signer: TransactionSigner;\n  }): void {\n    if (this.status !== AtomicTransactionComposerStatus.BUILDING) {\n      throw new Error(\n        'Cannot add transactions when composer status is not BUILDING'\n      );\n    }\n\n    if (\n      this.transactions.length + method.txnCount() >\n      AtomicTransactionComposer.MAX_GROUP_SIZE\n    ) {\n      throw new Error(\n        `Adding additional transactions exceeds the maximum atomic group size of ${AtomicTransactionComposer.MAX_GROUP_SIZE}`\n      );\n    }\n\n    if (appID === 0) {\n      if (\n        approvalProgram == null ||\n        clearProgram == null ||\n        numGlobalInts == null ||\n        numGlobalByteSlices == null ||\n        numLocalInts == null ||\n        numLocalByteSlices == null\n      ) {\n        throw new Error(\n          'One of the following required parameters for application creation is missing: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices'\n        );\n      }\n    } else if (onComplete === OnApplicationComplete.UpdateApplicationOC) {\n      if (approvalProgram == null || clearProgram == null) {\n        throw new Error(\n          'One of the following required parameters for OnApplicationComplete.UpdateApplicationOC is missing: approvalProgram, clearProgram'\n        );\n      }\n      if (\n        numGlobalInts != null ||\n        numGlobalByteSlices != null ||\n        numLocalInts != null ||\n        numLocalByteSlices != null ||\n        extraPages != null\n      ) {\n        throw new Error(\n          'One of the following application creation parameters were set on a non-creation call: numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages'\n        );\n      }\n    } else if (\n      approvalProgram != null ||\n      clearProgram != null ||\n      numGlobalInts != null ||\n      numGlobalByteSlices != null ||\n      numLocalInts != null ||\n      numLocalByteSlices != null ||\n      extraPages != null\n    ) {\n      throw new Error(\n        'One of the following application creation parameters were set on a non-creation call: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages'\n      );\n    }\n\n    if (methodArgs == null) {\n      // eslint-disable-next-line no-param-reassign\n      methodArgs = [];\n    }\n\n    if (methodArgs.length !== method.args.length) {\n      throw new Error(\n        `Incorrect number of method arguments. Expected ${method.args.length}, got ${methodArgs.length}`\n      );\n    }\n\n    let basicArgTypes: ABIType[] = [];\n    let basicArgValues: ABIValue[] = [];\n    const txnArgs: TransactionWithSigner[] = [];\n    const refArgTypes: ABIReferenceType[] = [];\n    const refArgValues: ABIValue[] = [];\n    const refArgIndexToBasicArgIndex: Map<number, number> = new Map();\n    // TODO: Box encoding for ABI\n    const boxReferences: BoxReference[] = !boxes ? [] : boxes;\n\n    for (let i = 0; i < methodArgs.length; i++) {\n      let argType = method.args[i].type;\n      const argValue = methodArgs[i];\n\n      if (abiTypeIsTransaction(argType)) {\n        if (\n          !isTransactionWithSigner(argValue) ||\n          !abiCheckTransactionType(argType, argValue.txn)\n        ) {\n          throw new Error(\n            `Expected ${argType} transaction for argument at index ${i}`\n          );\n        }\n        if (argValue.txn.group && argValue.txn.group.some((v) => v !== 0)) {\n          throw new Error('Cannot add a transaction with nonzero group ID');\n        }\n        txnArgs.push(argValue);\n        continue;\n      }\n\n      if (isTransactionWithSigner(argValue)) {\n        throw new Error(\n          `Expected non-transaction value for argument at index ${i}`\n        );\n      }\n\n      if (abiTypeIsReference(argType)) {\n        refArgIndexToBasicArgIndex.set(\n          refArgTypes.length,\n          basicArgTypes.length\n        );\n        refArgTypes.push(argType);\n        refArgValues.push(argValue);\n        // treat the reference as a uint8 for encoding purposes\n        argType = new ABIUintType(8);\n      }\n\n      if (typeof argType === 'string') {\n        throw new Error(`Unknown ABI type: ${argType}`);\n      }\n\n      basicArgTypes.push(argType);\n      basicArgValues.push(argValue);\n    }\n\n    const resolvedRefIndexes: number[] = [];\n    const foreignAccounts: string[] =\n      appAccounts == null ? [] : appAccounts.slice();\n    const foreignApps: number[] =\n      appForeignApps == null ? [] : appForeignApps.slice();\n    const foreignAssets: number[] =\n      appForeignAssets == null ? [] : appForeignAssets.slice();\n    for (let i = 0; i < refArgTypes.length; i++) {\n      const refType = refArgTypes[i];\n      const refValue = refArgValues[i];\n      let resolved = 0;\n\n      switch (refType) {\n        case ABIReferenceType.account: {\n          const addressType = new ABIAddressType();\n          const address = addressType.decode(addressType.encode(refValue));\n          resolved = populateForeignArray(address, foreignAccounts, sender);\n          break;\n        }\n        case ABIReferenceType.application: {\n          const uint64Type = new ABIUintType(64);\n          const refAppID = uint64Type.decode(uint64Type.encode(refValue));\n          if (refAppID > Number.MAX_SAFE_INTEGER) {\n            throw new Error(\n              `Expected safe integer for application value, got ${refAppID}`\n            );\n          }\n          resolved = populateForeignArray(Number(refAppID), foreignApps, appID);\n          break;\n        }\n        case ABIReferenceType.asset: {\n          const uint64Type = new ABIUintType(64);\n          const refAssetID = uint64Type.decode(uint64Type.encode(refValue));\n          if (refAssetID > Number.MAX_SAFE_INTEGER) {\n            throw new Error(\n              `Expected safe integer for asset value, got ${refAssetID}`\n            );\n          }\n          resolved = populateForeignArray(Number(refAssetID), foreignAssets);\n          break;\n        }\n        default:\n          throw new Error(`Unknown reference type: ${refType}`);\n      }\n\n      resolvedRefIndexes.push(resolved);\n    }\n\n    for (let i = 0; i < resolvedRefIndexes.length; i++) {\n      const basicArgIndex = refArgIndexToBasicArgIndex.get(i);\n      basicArgValues[basicArgIndex] = resolvedRefIndexes[i];\n    }\n\n    if (basicArgTypes.length > MAX_APP_ARGS - 1) {\n      const lastArgTupleTypes = basicArgTypes.slice(MAX_APP_ARGS - 2);\n      const lastArgTupleValues = basicArgValues.slice(MAX_APP_ARGS - 2);\n\n      basicArgTypes = basicArgTypes.slice(0, MAX_APP_ARGS - 2);\n      basicArgValues = basicArgValues.slice(0, MAX_APP_ARGS - 2);\n\n      basicArgTypes.push(new ABITupleType(lastArgTupleTypes));\n      basicArgValues.push(lastArgTupleValues);\n    }\n\n    const appArgsEncoded: Uint8Array[] = [method.getSelector()];\n    for (let i = 0; i < basicArgTypes.length; i++) {\n      appArgsEncoded.push(basicArgTypes[i].encode(basicArgValues[i]));\n    }\n\n    const appCall = {\n      txn: makeApplicationCallTxnFromObject({\n        from: sender,\n        appIndex: appID,\n        appArgs: appArgsEncoded,\n        accounts: foreignAccounts,\n        foreignApps,\n        foreignAssets,\n        boxes: boxReferences,\n        onComplete:\n          onComplete == null ? OnApplicationComplete.NoOpOC : onComplete,\n        approvalProgram,\n        clearProgram,\n        numGlobalInts,\n        numGlobalByteSlices,\n        numLocalInts,\n        numLocalByteSlices,\n        extraPages,\n        lease,\n        note,\n        rekeyTo,\n        suggestedParams,\n      }),\n      signer,\n    };\n\n    this.transactions.push(...txnArgs, appCall);\n    this.methodCalls.set(this.transactions.length - 1, method);\n  }\n\n  /**\n   * Finalize the transaction group and returned the finalized transactions.\n   *\n   * The composer's status will be at least BUILT after executing this method.\n   */\n  buildGroup(): TransactionWithSigner[] {\n    if (this.status === AtomicTransactionComposerStatus.BUILDING) {\n      if (this.transactions.length === 0) {\n        throw new Error('Cannot build a group with 0 transactions');\n      }\n      if (this.transactions.length > 1) {\n        assignGroupID(\n          this.transactions.map((txnWithSigner) => txnWithSigner.txn)\n        );\n      }\n      this.status = AtomicTransactionComposerStatus.BUILT;\n    }\n    return this.transactions;\n  }\n\n  /**\n   * Obtain signatures for each transaction in this group. If signatures have already been obtained,\n   * this method will return cached versions of the signatures.\n   *\n   * The composer's status will be at least SIGNED after executing this method.\n   *\n   * An error will be thrown if signing any of the transactions fails.\n   *\n   * @returns A promise that resolves to an array of signed transactions.\n   */\n  async gatherSignatures(): Promise<Uint8Array[]> {\n    if (this.status >= AtomicTransactionComposerStatus.SIGNED) {\n      return this.signedTxns;\n    }\n\n    // retrieve built transactions and verify status is BUILT\n    const txnsWithSigners = this.buildGroup();\n    const txnGroup = txnsWithSigners.map((txnWithSigner) => txnWithSigner.txn);\n\n    const indexesPerSigner: Map<TransactionSigner, number[]> = new Map();\n\n    for (let i = 0; i < txnsWithSigners.length; i++) {\n      const { signer } = txnsWithSigners[i];\n\n      if (!indexesPerSigner.has(signer)) {\n        indexesPerSigner.set(signer, []);\n      }\n\n      indexesPerSigner.get(signer).push(i);\n    }\n\n    const orderedSigners = Array.from(indexesPerSigner);\n\n    const batchedSigs = await Promise.all(\n      orderedSigners.map(([signer, indexes]) => signer(txnGroup, indexes))\n    );\n\n    const signedTxns: Array<Uint8Array | null> = txnsWithSigners.map(\n      () => null\n    );\n\n    for (\n      let signerIndex = 0;\n      signerIndex < orderedSigners.length;\n      signerIndex++\n    ) {\n      const indexes = orderedSigners[signerIndex][1];\n      const sigs = batchedSigs[signerIndex];\n\n      for (let i = 0; i < indexes.length; i++) {\n        signedTxns[indexes[i]] = sigs[i];\n      }\n    }\n\n    if (!signedTxns.every((sig) => sig != null)) {\n      throw new Error(`Missing signatures. Got ${signedTxns}`);\n    }\n\n    const txIDs = signedTxns.map((stxn, index) => {\n      try {\n        return decodeSignedTransaction(stxn).txn.txID();\n      } catch (err) {\n        throw new Error(\n          `Cannot decode signed transaction at index ${index}. ${err}`\n        );\n      }\n    });\n\n    this.signedTxns = signedTxns;\n    this.txIDs = txIDs;\n    this.status = AtomicTransactionComposerStatus.SIGNED;\n\n    return signedTxns;\n  }\n\n  /**\n   * Send the transaction group to the network, but don't wait for it to be committed to a block. An\n   * error will be thrown if submission fails.\n   *\n   * The composer's status must be SUBMITTED or lower before calling this method. If submission is\n   * successful, this composer's status will update to SUBMITTED.\n   *\n   * Note: a group can only be submitted again if it fails.\n   *\n   * @param client - An Algodv2 client\n   *\n   * @returns A promise that, upon success, resolves to a list of TxIDs of the submitted transactions.\n   */\n  async submit(client: Algodv2): Promise<string[]> {\n    if (this.status > AtomicTransactionComposerStatus.SUBMITTED) {\n      throw new Error('Transaction group cannot be resubmitted');\n    }\n\n    const stxns = await this.gatherSignatures();\n\n    await client.sendRawTransaction(stxns).do();\n\n    this.status = AtomicTransactionComposerStatus.SUBMITTED;\n\n    return this.txIDs;\n  }\n\n  /**\n   * Simulates the transaction group in the network.\n   *\n   * The composer will try to sign any transactions in the group, then simulate\n   * the results.\n   * Simulating the group will not change the composer's status.\n   *\n   * @param client - An Algodv2 client\n   *\n   * @returns A promise that, upon success, resolves to an object containing an\n   *   array of results containing one element for each method call transaction\n   *   in this group (ABIResult[]) and the SimulateResponse object.\n   */\n  async simulate(\n    client: Algodv2\n  ): Promise<{\n    methodResults: ABIResult[];\n    simulateResponse: SimulateResponse;\n  }> {\n    if (this.status > AtomicTransactionComposerStatus.SUBMITTED) {\n      throw new Error(\n        'Simulated Transaction group has already been submitted to the network'\n      );\n    }\n\n    const stxns = await this.gatherSignatures();\n\n    const simulateResponse = await client.simulateRawTransactions(stxns).do();\n\n    // Parse method response\n    const methodResults: ABIResult[] = [];\n    for (const [txnIndex, method] of this.methodCalls) {\n      const txID = this.txIDs[txnIndex];\n      const pendingInfo =\n        simulateResponse.txnGroups[0].txnResults[txnIndex].txnResult;\n\n      const methodResult: ABIResult = {\n        txID,\n        rawReturnValue: new Uint8Array(),\n        method,\n      };\n\n      methodResults.push(\n        AtomicTransactionComposer.parseMethodResponse(\n          method,\n          methodResult,\n          pendingInfo.get_obj_for_encoding()\n        )\n      );\n    }\n\n    return { methodResults, simulateResponse };\n  }\n\n  /**\n   * Send the transaction group to the network and wait until it's committed to a block. An error\n   * will be thrown if submission or execution fails.\n   *\n   * The composer's status must be SUBMITTED or lower before calling this method, since execution is\n   * only allowed once. If submission is successful, this composer's status will update to SUBMITTED.\n   * If the execution is also successful, this composer's status will update to COMMITTED.\n   *\n   * Note: a group can only be submitted again if it fails.\n   *\n   * @param client - An Algodv2 client\n   * @param waitRounds - The maximum number of rounds to wait for transaction confirmation\n   *\n   * @returns A promise that, upon success, resolves to an object containing the confirmed round for\n   *   this transaction, the txIDs of the submitted transactions, and an array of results containing\n   *   one element for each method call transaction in this group.\n   */\n  async execute(\n    client: Algodv2,\n    waitRounds: number\n  ): Promise<{\n    confirmedRound: number;\n    txIDs: string[];\n    methodResults: ABIResult[];\n  }> {\n    if (this.status === AtomicTransactionComposerStatus.COMMITTED) {\n      throw new Error(\n        'Transaction group has already been executed successfully'\n      );\n    }\n\n    const txIDs = await this.submit(client);\n    this.status = AtomicTransactionComposerStatus.SUBMITTED;\n\n    const firstMethodCallIndex = this.transactions.findIndex((_, index) =>\n      this.methodCalls.has(index)\n    );\n    const indexToWaitFor =\n      firstMethodCallIndex === -1 ? 0 : firstMethodCallIndex;\n    const confirmedTxnInfo = await waitForConfirmation(\n      client,\n      txIDs[indexToWaitFor],\n      waitRounds\n    );\n    this.status = AtomicTransactionComposerStatus.COMMITTED;\n\n    const confirmedRound: number = confirmedTxnInfo['confirmed-round'];\n\n    const methodResults: ABIResult[] = [];\n\n    for (const [txnIndex, method] of this.methodCalls) {\n      const txID = txIDs[txnIndex];\n\n      let methodResult: ABIResult = {\n        txID,\n        rawReturnValue: new Uint8Array(),\n        method,\n      };\n\n      try {\n        const pendingInfo =\n          txnIndex === firstMethodCallIndex\n            ? confirmedTxnInfo\n            : // eslint-disable-next-line no-await-in-loop\n              await client.pendingTransactionInformation(txID).do();\n\n        methodResult = AtomicTransactionComposer.parseMethodResponse(\n          method,\n          methodResult,\n          pendingInfo\n        );\n      } catch (err) {\n        methodResult.decodeError = err;\n      }\n\n      methodResults.push(methodResult);\n    }\n\n    return {\n      confirmedRound,\n      txIDs,\n      methodResults,\n    };\n  }\n\n  /**\n   * Parses a single ABI Method transaction log into a ABI result object.\n   *\n   * @param method\n   * @param methodResult\n   * @param pendingInfo\n   * @returns An ABIResult object\n   */\n  static parseMethodResponse(\n    method: ABIMethod,\n    methodResult: ABIResult,\n    pendingInfo: Record<string, any>\n  ): ABIResult {\n    const returnedResult: ABIResult = methodResult;\n    try {\n      returnedResult.txInfo = pendingInfo;\n      if (method.returns.type !== 'void') {\n        const logs: string[] = pendingInfo.logs || [];\n        if (logs.length === 0) {\n          throw new Error('App call transaction did not log a return value');\n        }\n\n        const lastLog = Buffer.from(logs[logs.length - 1], 'base64');\n        if (\n          lastLog.byteLength < 4 ||\n          !lastLog.slice(0, 4).equals(RETURN_PREFIX)\n        ) {\n          throw new Error('App call transaction did not log a return value');\n        }\n\n        returnedResult.rawReturnValue = new Uint8Array(lastLog.slice(4));\n        returnedResult.returnValue = method.returns.type.decode(\n          methodResult.rawReturnValue\n        );\n      }\n    } catch (err) {\n      returnedResult.decodeError = err;\n    }\n\n    return returnedResult;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}