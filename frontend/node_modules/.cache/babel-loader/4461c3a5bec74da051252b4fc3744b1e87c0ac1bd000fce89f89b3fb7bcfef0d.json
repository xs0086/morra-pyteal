{"ast":null,"code":"import { concatArrays } from '../utils/utils';\n// NOTE: at the moment we specifically do not use Buffer.writeBigUInt64BE and\n// Buffer.readBigUInt64BE. This is because projects using webpack v4\n// automatically include an old version of the npm `buffer` package (v4.9.2 at\n// the time of writing), and this old version does not have these methods.\n/**\n * encodeUint64 converts an integer to its binary representation.\n * @param num - The number to convert. This must be an unsigned integer less than\n *   2^64.\n * @returns An 8-byte typed array containing the big-endian encoding of the input\n *   integer.\n */\nexport function encodeUint64(num) {\n  const isInteger = typeof num === 'bigint' || Number.isInteger(num);\n  if (!isInteger || num < 0 || num > BigInt('0xffffffffffffffff')) {\n    throw new Error('Input is not a 64-bit unsigned integer');\n  }\n  const encoding = new Uint8Array(8);\n  const view = new DataView(encoding.buffer);\n  view.setBigUint64(0, BigInt(num));\n  return encoding;\n}\nexport function decodeUint64(data) {\n  let decodingMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'safe';\n  if (decodingMode !== 'safe' && decodingMode !== 'mixed' && decodingMode !== 'bigint') {\n    throw new Error(`Unknown decodingMode option: ${decodingMode}`);\n  }\n  if (data.byteLength === 0 || data.byteLength > 8) {\n    throw new Error(`Data has unacceptable length. Expected length is between 1 and 8, got ${data.byteLength}`);\n  }\n  // insert 0s at the beginning if data is smaller than 8 bytes\n  const padding = new Uint8Array(8 - data.byteLength);\n  const encoding = concatArrays(padding, data);\n  const view = new DataView(encoding.buffer);\n  const num = view.getBigUint64(0);\n  const isBig = num > BigInt(Number.MAX_SAFE_INTEGER);\n  if (decodingMode === 'safe') {\n    if (isBig) {\n      throw new Error(`Integer exceeds maximum safe integer: ${num.toString()}. Try decoding with \"mixed\" or \"safe\" decodingMode.`);\n    }\n    return Number(num);\n  }\n  if (decodingMode === 'mixed' && !isBig) {\n    return Number(num);\n  }\n  return num;\n}","map":{"version":3,"names":["concatArrays","encodeUint64","num","isInteger","Number","BigInt","Error","encoding","Uint8Array","view","DataView","buffer","setBigUint64","decodeUint64","data","decodingMode","arguments","length","undefined","byteLength","padding","getBigUint64","isBig","MAX_SAFE_INTEGER","toString"],"sources":["/home/danica/morra/frontend/node_modules/algosdk/src/encoding/uint64.ts"],"sourcesContent":["import { concatArrays } from '../utils/utils';\n\n// NOTE: at the moment we specifically do not use Buffer.writeBigUInt64BE and\n// Buffer.readBigUInt64BE. This is because projects using webpack v4\n// automatically include an old version of the npm `buffer` package (v4.9.2 at\n// the time of writing), and this old version does not have these methods.\n\n/**\n * encodeUint64 converts an integer to its binary representation.\n * @param num - The number to convert. This must be an unsigned integer less than\n *   2^64.\n * @returns An 8-byte typed array containing the big-endian encoding of the input\n *   integer.\n */\nexport function encodeUint64(num: number | bigint) {\n  const isInteger = typeof num === 'bigint' || Number.isInteger(num);\n\n  if (!isInteger || num < 0 || num > BigInt('0xffffffffffffffff')) {\n    throw new Error('Input is not a 64-bit unsigned integer');\n  }\n\n  const encoding = new Uint8Array(8);\n  const view = new DataView(encoding.buffer);\n  view.setBigUint64(0, BigInt(num));\n\n  return encoding;\n}\n\n/**\n * decodeUint64 produces an integer from a binary representation.\n * @param data - An typed array containing the big-endian encoding of an unsigned integer\n *   less than 2^64. This array must be at most 8 bytes long.\n * @param decodingMode - Configure how the integer will be\n *   decoded.\n *\n *   The options are:\n *   * \"safe\": The integer will be decoded as a Number, but if it is greater than\n *     Number.MAX_SAFE_INTEGER an error will be thrown.\n *   * \"mixed\": The integer will be decoded as a Number if it is less than or equal to\n *     Number.MAX_SAFE_INTEGER, otherwise it will be decoded as a BigInt.\n *   * \"bigint\": The integer will always be decoded as a BigInt.\n *\n *   Defaults to \"safe\" if not included.\n * @returns The integer that was encoded in the input data. The return type will\n *   be determined by the parameter decodingMode.\n */\nexport function decodeUint64(data: Uint8Array, decodingMode: 'safe'): number;\nexport function decodeUint64(\n  data: Uint8Array,\n  decodingMode: 'mixed'\n): number | bigint;\nexport function decodeUint64(data: Uint8Array, decodingMode: 'bigint'): bigint;\nexport function decodeUint64(data: any, decodingMode: any = 'safe') {\n  if (\n    decodingMode !== 'safe' &&\n    decodingMode !== 'mixed' &&\n    decodingMode !== 'bigint'\n  ) {\n    throw new Error(`Unknown decodingMode option: ${decodingMode}`);\n  }\n\n  if (data.byteLength === 0 || data.byteLength > 8) {\n    throw new Error(\n      `Data has unacceptable length. Expected length is between 1 and 8, got ${data.byteLength}`\n    );\n  }\n\n  // insert 0s at the beginning if data is smaller than 8 bytes\n  const padding = new Uint8Array(8 - data.byteLength);\n  const encoding = concatArrays(padding, data);\n  const view = new DataView(encoding.buffer);\n\n  const num = view.getBigUint64(0);\n  const isBig = num > BigInt(Number.MAX_SAFE_INTEGER);\n\n  if (decodingMode === 'safe') {\n    if (isBig) {\n      throw new Error(\n        `Integer exceeds maximum safe integer: ${num.toString()}. Try decoding with \"mixed\" or \"safe\" decodingMode.`\n      );\n    }\n    return Number(num);\n  }\n\n  if (decodingMode === 'mixed' && !isBig) {\n    return Number(num);\n  }\n\n  return num;\n}\n"],"mappings":"AAAA,SAASA,YAAY,QAAQ,gBAAgB;AAE7C;AACA;AACA;AACA;AAEA;;;;;;;AAOA,OAAM,SAAUC,YAAYA,CAACC,GAAoB;EAC/C,MAAMC,SAAS,GAAG,OAAOD,GAAG,KAAK,QAAQ,IAAIE,MAAM,CAACD,SAAS,CAACD,GAAG,CAAC;EAElE,IAAI,CAACC,SAAS,IAAID,GAAG,GAAG,CAAC,IAAIA,GAAG,GAAGG,MAAM,CAAC,oBAAoB,CAAC,EAAE;IAC/D,MAAM,IAAIC,KAAK,CAAC,wCAAwC,CAAC;;EAG3D,MAAMC,QAAQ,GAAG,IAAIC,UAAU,CAAC,CAAC,CAAC;EAClC,MAAMC,IAAI,GAAG,IAAIC,QAAQ,CAACH,QAAQ,CAACI,MAAM,CAAC;EAC1CF,IAAI,CAACG,YAAY,CAAC,CAAC,EAAEP,MAAM,CAACH,GAAG,CAAC,CAAC;EAEjC,OAAOK,QAAQ;AACjB;AA0BA,OAAM,SAAUM,YAAYA,CAACC,IAAS,EAA4B;EAAA,IAA1BC,YAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAoB,MAAM;EAChE,IACED,YAAY,KAAK,MAAM,IACvBA,YAAY,KAAK,OAAO,IACxBA,YAAY,KAAK,QAAQ,EACzB;IACA,MAAM,IAAIT,KAAK,CAAC,gCAAgCS,YAAY,EAAE,CAAC;;EAGjE,IAAID,IAAI,CAACK,UAAU,KAAK,CAAC,IAAIL,IAAI,CAACK,UAAU,GAAG,CAAC,EAAE;IAChD,MAAM,IAAIb,KAAK,CACb,yEAAyEQ,IAAI,CAACK,UAAU,EAAE,CAC3F;;EAGH;EACA,MAAMC,OAAO,GAAG,IAAIZ,UAAU,CAAC,CAAC,GAAGM,IAAI,CAACK,UAAU,CAAC;EACnD,MAAMZ,QAAQ,GAAGP,YAAY,CAACoB,OAAO,EAAEN,IAAI,CAAC;EAC5C,MAAML,IAAI,GAAG,IAAIC,QAAQ,CAACH,QAAQ,CAACI,MAAM,CAAC;EAE1C,MAAMT,GAAG,GAAGO,IAAI,CAACY,YAAY,CAAC,CAAC,CAAC;EAChC,MAAMC,KAAK,GAAGpB,GAAG,GAAGG,MAAM,CAACD,MAAM,CAACmB,gBAAgB,CAAC;EAEnD,IAAIR,YAAY,KAAK,MAAM,EAAE;IAC3B,IAAIO,KAAK,EAAE;MACT,MAAM,IAAIhB,KAAK,CACb,yCAAyCJ,GAAG,CAACsB,QAAQ,EAAE,qDAAqD,CAC7G;;IAEH,OAAOpB,MAAM,CAACF,GAAG,CAAC;;EAGpB,IAAIa,YAAY,KAAK,OAAO,IAAI,CAACO,KAAK,EAAE;IACtC,OAAOlB,MAAM,CAACF,GAAG,CAAC;;EAGpB,OAAOA,GAAG;AACZ"},"metadata":{},"sourceType":"module","externalDependencies":[]}